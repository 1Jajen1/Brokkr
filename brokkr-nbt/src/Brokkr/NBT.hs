module Brokkr.NBT (
  NBT
, Tag
, parseNBT
, putNBT
, module Brokkr.NBT.Codec
, module Brokkr.NBT.ByteOrder
, module Brokkr.NBT.NBTString
, module Brokkr.NBT.NBTError
) where

import Brokkr.NBT.Codec
import Brokkr.NBT.Internal
import Brokkr.NBT.ByteOrder
import Brokkr.NBT.NBTString
import Brokkr.NBT.NBTError

{-
  TODO:
    - Move to core lib
    - Add lens lib
    - Add optics lib
    - Add benchmarks in each package
      - core
        - parsing into nbt
        - java cesu8 validation
        - byteswapping
        - FromNBT/ToNBT
      - lens/optics
      - codec
    - utf-8 conversion
      - Add text dependency to write directly to text if we need to copy anyway
        Going through bytestring first is a perf penalty if we needed to copy
    - Add codec interface for reading/writing nbt
      - Add TH variant that does the following:
        - When entering anything simply-ish, simply read and apply the transformation function if any
          - This includes all prims/vectors/lists
        - Compounds
          - When entering a compound we setup n variables for each key we are looking for
            (primtypes will get prim variables, boxed types STRefs)
          - Also setup a bitset of variables we already found
            (Uses Word or (# Word, ... #) depending on how many values we need to write)
          - On each key
            - Push the key through a trie generated by flatparse
            - If matching
              - if the tag type matches we write to the mutable ref and set the bit in the bitset
              - otherwise we fail and report the mismatched tag type
            - If not matching we validate but ignore the nbt (validate both the key and the tag)
          - On TagEnd
            - If BitSet == 0 we are done, read all variables and apply to the transformation function
            - Otherwise we failed, find 1 bits in the bitset and report the missing keys
      => This nicely handles compounds and should be bloody fast because we don't need to sort
         the keys, we don't allocate for unused tags and we also don't validate matching keys.
         The obvious downside is code generation
-}

-- Interface:
--
-- Manipulating nbt type:
-- Lenses are the nicest here, but move that to other package

-- Parsing into domain types:
-- 2 options:
--   Specialized parser that skips unused values and only validates
--     Bit hard and will be an annoying api
--     We'd still have to validate everything so probably not worth
--      as this only saves the sorted insert
--   Parse from nbt type
--     Easy to do and with fast nbt parsing this will also be fast

{-

Things a high level api needs to do safely:
- Modified utf-8 handling
  - Matching should convert to modified utf8 and then match
  - When reading out convert to utf8
  => Ideas:
    - Store if the NBTString is already valid utf-8, which will often be the case
    - String literals are a bit annoying?
    - NBTString -> Text is annoying because I probably have to copy unless I have plain foreign ptrs
    - The conversion needs to be pure haskell code, which is fine as we only need it rarely

- Big endian handling
  - We byteswap all single element primitives. It is cheap enough there
  - We don't byteswap arrays eagerly because with an immutable interface
    we'd have to copy. We do have a really fast byteswapping implementation tho
  => Ideas:
    - Honestly just having IntBE on the api is fine, we can easily do
      toNative/unsafeToNative and clarify how and why it's unsafe
      - How is it unsafe/safe?
        It modifies the original input. So using unsafeToNative is safe as long as both the bytestring we
        initially parsed and the nbt we convert from is used at most once. So for example decoding and then
        using that exact same nbt object again to encode something is unsafe
        Is this fine? Probably. When parsing domain objects the input string and the nbt are usually thrown away anyway
        When modifying nbt lenses can can add a tiny bit more safety as we can swap back on write
-}

{-

Parsing into domain types:



-}

